{"ast":null,"code":"'use strict';\n\nconst multibase = require('multibase');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst log = require('debug')('ipfs-http-client:pubsub:subscribe');\n\nconst SubscriptionTracker = require('./subscription-tracker');\n\nconst configure = require('../lib/configure');\n\nconst toUrlSearchParams = require('../lib/to-url-search-params');\n\nmodule.exports = configure((api, options) => {\n  const subsTracker = SubscriptionTracker.singleton();\n\n  const publish = require('./publish')(options);\n\n  return async (topic, handler, options = {}) => {\n    options.signal = subsTracker.subscribe(topic, handler, options.signal);\n    let res; // In Firefox, the initial call to fetch does not resolve until some data\n    // is received. If this doesn't happen within 1 second send an empty message\n    // to kickstart the process.\n\n    const ffWorkaround = setTimeout(async () => {\n      log(`Publishing empty message to \"${topic}\" to resolve subscription request`);\n\n      try {\n        await publish(topic, Buffer.alloc(0), options);\n      } catch (err) {\n        log('Failed to publish empty message', err);\n      }\n    }, 1000);\n\n    try {\n      res = await api.post('pubsub/sub', {\n        timeout: options.timeout,\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          arg: topic,\n          ...options\n        }),\n        headers: options.headers\n      });\n    } catch (err) {\n      // Initial subscribe fail, ensure we clean up\n      subsTracker.unsubscribe(topic, handler);\n      throw err;\n    }\n\n    clearTimeout(ffWorkaround);\n    readMessages(res.ndjson(), {\n      onMessage: handler,\n      onEnd: () => subsTracker.unsubscribe(topic, handler),\n      onError: options.onError\n    });\n  };\n});\n\nasync function readMessages(msgStream, {\n  onMessage,\n  onEnd,\n  onError\n}) {\n  onError = onError || log;\n\n  try {\n    for await (const msg of msgStream) {\n      try {\n        onMessage({\n          from: multibase.encode('base58btc', Buffer.from(msg.from, 'base64')).toString().slice(1),\n          data: Buffer.from(msg.data, 'base64'),\n          seqno: Buffer.from(msg.seqno, 'base64'),\n          topicIDs: msg.topicIDs\n        });\n      } catch (err) {\n        err.message = `Failed to parse pubsub message: ${err.message}`;\n        onError(err, false, msg); // Not fatal\n      }\n    }\n  } catch (err) {\n    // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n    // Temporarily use the name property instead.\n    if (err.type !== 'aborted' && err.name !== 'AbortError') {\n      onError(err, true); // Fatal\n    }\n  } finally {\n    onEnd();\n  }\n}","map":{"version":3,"sources":["/Users/velkoskis/Desktop/Claims/node_modules/ipfs-http-client/src/pubsub/subscribe.js"],"names":["multibase","require","Buffer","log","SubscriptionTracker","configure","toUrlSearchParams","module","exports","api","options","subsTracker","singleton","publish","topic","handler","signal","subscribe","res","ffWorkaround","setTimeout","alloc","err","post","timeout","searchParams","arg","headers","unsubscribe","clearTimeout","readMessages","ndjson","onMessage","onEnd","onError","msgStream","msg","from","encode","toString","slice","data","seqno","topicIDs","message","type","name"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multibase = require('multibase')\nconst { Buffer } = require('buffer')\nconst log = require('debug')('ipfs-http-client:pubsub:subscribe')\nconst SubscriptionTracker = require('./subscription-tracker')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure((api, options) => {\n  const subsTracker = SubscriptionTracker.singleton()\n  const publish = require('./publish')(options)\n\n  return async (topic, handler, options = {}) => {\n    options.signal = subsTracker.subscribe(topic, handler, options.signal)\n\n    let res\n\n    // In Firefox, the initial call to fetch does not resolve until some data\n    // is received. If this doesn't happen within 1 second send an empty message\n    // to kickstart the process.\n    const ffWorkaround = setTimeout(async () => {\n      log(`Publishing empty message to \"${topic}\" to resolve subscription request`)\n      try {\n        await publish(topic, Buffer.alloc(0), options)\n      } catch (err) {\n        log('Failed to publish empty message', err)\n      }\n    }, 1000)\n\n    try {\n      res = await api.post('pubsub/sub', {\n        timeout: options.timeout,\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          arg: topic,\n          ...options\n        }),\n        headers: options.headers\n      })\n    } catch (err) { // Initial subscribe fail, ensure we clean up\n      subsTracker.unsubscribe(topic, handler)\n      throw err\n    }\n\n    clearTimeout(ffWorkaround)\n\n    readMessages(res.ndjson(), {\n      onMessage: handler,\n      onEnd: () => subsTracker.unsubscribe(topic, handler),\n      onError: options.onError\n    })\n  }\n})\n\nasync function readMessages (msgStream, { onMessage, onEnd, onError }) {\n  onError = onError || log\n\n  try {\n    for await (const msg of msgStream) {\n      try {\n        onMessage({\n          from: multibase.encode('base58btc', Buffer.from(msg.from, 'base64')).toString().slice(1),\n          data: Buffer.from(msg.data, 'base64'),\n          seqno: Buffer.from(msg.seqno, 'base64'),\n          topicIDs: msg.topicIDs\n        })\n      } catch (err) {\n        err.message = `Failed to parse pubsub message: ${err.message}`\n        onError(err, false, msg) // Not fatal\n      }\n    }\n  } catch (err) {\n    // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n    // Temporarily use the name property instead.\n    if (err.type !== 'aborted' && err.name !== 'AbortError') {\n      onError(err, true) // Fatal\n    }\n  } finally {\n    onEnd()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}