{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst protons = require('protons');\n\nconst proto = protons(require('./dag.proto'));\n\nconst DAGLink = require('./dag-link/dagLink');\n\nconst DAGNode = require('./dag-node/dagNode');\n\nconst {\n  serializeDAGNodeLike\n} = require('./serialize');\n\nconst genCid = require('./genCid');\n\nexports = module.exports;\nexports.codec = genCid.codec;\nexports.defaultHashAlg = genCid.defaultHashAlg;\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\n\nconst cid = (binaryBlob, userOptions) => {\n  return genCid.cid(binaryBlob, userOptions);\n};\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Buffer} - The encoded binary representation\n */\n\n\nconst serialize = node => {\n  if (DAGNode.isDAGNode(node)) {\n    return node.serialize();\n  } else {\n    return serializeDAGNodeLike(node.Data, node.Links);\n  }\n};\n/**\n * Deserialize PB block into the internal representation.\n *\n * @param {Buffer} buffer - Binary representation of a PB block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\n\n\nconst deserialize = buffer => {\n  const pbn = proto.PBNode.decode(buffer);\n  const links = pbn.Links.map(link => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash);\n  });\n  const data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data;\n  return new DAGNode(data, links, buffer.length);\n};\n\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.cid = cid;","map":{"version":3,"sources":["/Users/velkoskis/Desktop/Claims/node_modules/ipld-dag-pb/src/util.js"],"names":["Buffer","require","protons","proto","DAGLink","DAGNode","serializeDAGNodeLike","genCid","exports","module","codec","defaultHashAlg","cid","binaryBlob","userOptions","serialize","node","isDAGNode","Data","Links","deserialize","buffer","pbn","PBNode","decode","links","map","link","Name","Tsize","Hash","data","alloc","length"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAME,KAAK,GAAGD,OAAO,CAACD,OAAO,CAAC,aAAD,CAAR,CAArB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,oBAAD,CAAvB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,oBAAD,CAAvB;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAA2BL,OAAO,CAAC,aAAD,CAAxC;;AACA,MAAMM,MAAM,GAAGN,OAAO,CAAC,UAAD,CAAtB;;AAEAO,OAAO,GAAGC,MAAM,CAACD,OAAjB;AAEAA,OAAO,CAACE,KAAR,GAAgBH,MAAM,CAACG,KAAvB;AACAF,OAAO,CAACG,cAAR,GAAyBJ,MAAM,CAACI,cAAhC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,GAAG,GAAG,CAACC,UAAD,EAAaC,WAAb,KAA6B;AACvC,SAAOP,MAAM,CAACK,GAAP,CAAWC,UAAX,EAAuBC,WAAvB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,SAAS,GAAIC,IAAD,IAAU;AAC1B,MAAIX,OAAO,CAACY,SAAR,CAAkBD,IAAlB,CAAJ,EAA6B;AAC3B,WAAOA,IAAI,CAACD,SAAL,EAAP;AACD,GAFD,MAEO;AACL,WAAOT,oBAAoB,CAACU,IAAI,CAACE,IAAN,EAAYF,IAAI,CAACG,KAAjB,CAA3B;AACD;AACF,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,WAAW,GAAIC,MAAD,IAAY;AAC9B,QAAMC,GAAG,GAAGnB,KAAK,CAACoB,MAAN,CAAaC,MAAb,CAAoBH,MAApB,CAAZ;AAEA,QAAMI,KAAK,GAAGH,GAAG,CAACH,KAAJ,CAAUO,GAAV,CAAeC,IAAD,IAAU;AACpC,WAAO,IAAIvB,OAAJ,CAAYuB,IAAI,CAACC,IAAjB,EAAuBD,IAAI,CAACE,KAA5B,EAAmCF,IAAI,CAACG,IAAxC,CAAP;AACD,GAFa,CAAd;AAIA,QAAMC,IAAI,GAAGT,GAAG,CAACJ,IAAJ,IAAY,IAAZ,GAAmBlB,MAAM,CAACgC,KAAP,CAAa,CAAb,CAAnB,GAAqCV,GAAG,CAACJ,IAAtD;AAEA,SAAO,IAAIb,OAAJ,CAAY0B,IAAZ,EAAkBN,KAAlB,EAAyBJ,MAAM,CAACY,MAAhC,CAAP;AACD,CAVD;;AAYAzB,OAAO,CAACO,SAAR,GAAoBA,SAApB;AACAP,OAAO,CAACY,WAAR,GAAsBA,WAAtB;AACAZ,OAAO,CAACI,GAAR,GAAcA,GAAd","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto'))\nconst DAGLink = require('./dag-link/dagLink')\nconst DAGNode = require('./dag-node/dagNode')\nconst { serializeDAGNodeLike } = require('./serialize')\nconst genCid = require('./genCid')\n\nexports = module.exports\n\nexports.codec = genCid.codec\nexports.defaultHashAlg = genCid.defaultHashAlg\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\nconst cid = (binaryBlob, userOptions) => {\n  return genCid.cid(binaryBlob, userOptions)\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Buffer} - The encoded binary representation\n */\nconst serialize = (node) => {\n  if (DAGNode.isDAGNode(node)) {\n    return node.serialize()\n  } else {\n    return serializeDAGNodeLike(node.Data, node.Links)\n  }\n}\n\n/**\n * Deserialize PB block into the internal representation.\n *\n * @param {Buffer} buffer - Binary representation of a PB block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\nconst deserialize = (buffer) => {\n  const pbn = proto.PBNode.decode(buffer)\n\n  const links = pbn.Links.map((link) => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash)\n  })\n\n  const data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data\n\n  return new DAGNode(data, links, buffer.length)\n}\n\nexports.serialize = serialize\nexports.deserialize = deserialize\nexports.cid = cid\n"]},"metadata":{},"sourceType":"script"}