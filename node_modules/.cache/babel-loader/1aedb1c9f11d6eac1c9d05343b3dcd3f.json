{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst CID = require('cids');\n\nconst configure = require('./lib/configure');\n\nconst toUrlSearchParams = require('./lib/to-url-search-params');\n\nmodule.exports = configure(api => {\n  return async function* ls(path, options = {}) {\n    const res = await api.post('ls', {\n      timeout: options.timeout,\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${Buffer.isBuffer(path) ? new CID(path) : path}`,\n        ...options\n      }),\n      headers: options.headers\n    });\n\n    for await (let result of res.ndjson()) {\n      result = result.Objects;\n\n      if (!result) {\n        throw new Error('expected .Objects in results');\n      }\n\n      result = result[0];\n\n      if (!result) {\n        throw new Error('expected one array in results.Objects');\n      }\n\n      result = result.Links;\n\n      if (!Array.isArray(result)) {\n        throw new Error('expected one array in results.Objects[0].Links');\n      }\n\n      for (const link of result) {\n        const entry = {\n          name: link.Name,\n          path: path + '/' + link.Name,\n          size: link.Size,\n          cid: new CID(link.Hash),\n          type: typeOf(link),\n          depth: link.Depth || 1\n        };\n\n        if (link.Mode) {\n          entry.mode = parseInt(link.Mode, 8);\n        }\n\n        if (link.Mtime !== undefined && link.Mtime !== null) {\n          entry.mtime = {\n            secs: link.Mtime\n          };\n\n          if (link.MtimeNsecs !== undefined && link.MtimeNsecs !== null) {\n            entry.mtime.nsecs = link.MtimeNsecs;\n          }\n        }\n\n        yield entry;\n      }\n    }\n  };\n});\n\nfunction typeOf(link) {\n  switch (link.Type) {\n    case 1:\n    case 5:\n      return 'dir';\n\n    case 2:\n      return 'file';\n\n    default:\n      return 'unknown';\n  }\n}","map":{"version":3,"sources":["/Users/velkoskis/Desktop/Claims/node_modules/ipfs-http-client/src/ls.js"],"names":["Buffer","require","CID","configure","toUrlSearchParams","module","exports","api","ls","path","options","res","post","timeout","signal","searchParams","arg","isBuffer","headers","result","ndjson","Objects","Error","Links","Array","isArray","link","entry","name","Name","size","Size","cid","Hash","type","typeOf","depth","Depth","Mode","mode","parseInt","Mtime","undefined","mtime","secs","MtimeNsecs","nsecs","Type"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,iBAAD,CAAzB;;AACA,MAAMG,iBAAiB,GAAGH,OAAO,CAAC,4BAAD,CAAjC;;AAEAI,MAAM,CAACC,OAAP,GAAiBH,SAAS,CAACI,GAAG,IAAI;AAChC,SAAO,gBAAiBC,EAAjB,CAAqBC,IAArB,EAA2BC,OAAO,GAAG,EAArC,EAAyC;AAC9C,UAAMC,GAAG,GAAG,MAAMJ,GAAG,CAACK,IAAJ,CAAS,IAAT,EAAe;AAC/BC,MAAAA,OAAO,EAAEH,OAAO,CAACG,OADc;AAE/BC,MAAAA,MAAM,EAAEJ,OAAO,CAACI,MAFe;AAG/BC,MAAAA,YAAY,EAAEX,iBAAiB,CAAC;AAC9BY,QAAAA,GAAG,EAAG,GAAEhB,MAAM,CAACiB,QAAP,CAAgBR,IAAhB,IAAwB,IAAIP,GAAJ,CAAQO,IAAR,CAAxB,GAAwCA,IAAK,EADvB;AAE9B,WAAGC;AAF2B,OAAD,CAHA;AAO/BQ,MAAAA,OAAO,EAAER,OAAO,CAACQ;AAPc,KAAf,CAAlB;;AAUA,eAAW,IAAIC,MAAf,IAAyBR,GAAG,CAACS,MAAJ,EAAzB,EAAuC;AACrCD,MAAAA,MAAM,GAAGA,MAAM,CAACE,OAAhB;;AAEA,UAAI,CAACF,MAAL,EAAa;AACX,cAAM,IAAIG,KAAJ,CAAU,8BAAV,CAAN;AACD;;AAEDH,MAAAA,MAAM,GAAGA,MAAM,CAAC,CAAD,CAAf;;AACA,UAAI,CAACA,MAAL,EAAa;AACX,cAAM,IAAIG,KAAJ,CAAU,uCAAV,CAAN;AACD;;AAEDH,MAAAA,MAAM,GAAGA,MAAM,CAACI,KAAhB;;AACA,UAAI,CAACC,KAAK,CAACC,OAAN,CAAcN,MAAd,CAAL,EAA4B;AAC1B,cAAM,IAAIG,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED,WAAK,MAAMI,IAAX,IAAmBP,MAAnB,EAA2B;AACzB,cAAMQ,KAAK,GAAG;AACZC,UAAAA,IAAI,EAAEF,IAAI,CAACG,IADC;AAEZpB,UAAAA,IAAI,EAAEA,IAAI,GAAG,GAAP,GAAaiB,IAAI,CAACG,IAFZ;AAGZC,UAAAA,IAAI,EAAEJ,IAAI,CAACK,IAHC;AAIZC,UAAAA,GAAG,EAAE,IAAI9B,GAAJ,CAAQwB,IAAI,CAACO,IAAb,CAJO;AAKZC,UAAAA,IAAI,EAAEC,MAAM,CAACT,IAAD,CALA;AAMZU,UAAAA,KAAK,EAAEV,IAAI,CAACW,KAAL,IAAc;AANT,SAAd;;AASA,YAAIX,IAAI,CAACY,IAAT,EAAe;AACbX,UAAAA,KAAK,CAACY,IAAN,GAAaC,QAAQ,CAACd,IAAI,CAACY,IAAN,EAAY,CAAZ,CAArB;AACD;;AAED,YAAIZ,IAAI,CAACe,KAAL,KAAeC,SAAf,IAA4BhB,IAAI,CAACe,KAAL,KAAe,IAA/C,EAAqD;AACnDd,UAAAA,KAAK,CAACgB,KAAN,GAAc;AACZC,YAAAA,IAAI,EAAElB,IAAI,CAACe;AADC,WAAd;;AAIA,cAAIf,IAAI,CAACmB,UAAL,KAAoBH,SAApB,IAAiChB,IAAI,CAACmB,UAAL,KAAoB,IAAzD,EAA+D;AAC7DlB,YAAAA,KAAK,CAACgB,KAAN,CAAYG,KAAZ,GAAoBpB,IAAI,CAACmB,UAAzB;AACD;AACF;;AAED,cAAMlB,KAAN;AACD;AACF;AACF,GAvDD;AAwDD,CAzDyB,CAA1B;;AA2DA,SAASQ,MAAT,CAAiBT,IAAjB,EAAuB;AACrB,UAAQA,IAAI,CAACqB,IAAb;AACE,SAAK,CAAL;AACA,SAAK,CAAL;AACE,aAAO,KAAP;;AACF,SAAK,CAAL;AACE,aAAO,MAAP;;AACF;AACE,aAAO,SAAP;AAPJ;AASD","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst CID = require('cids')\nconst configure = require('./lib/configure')\nconst toUrlSearchParams = require('./lib/to-url-search-params')\n\nmodule.exports = configure(api => {\n  return async function * ls (path, options = {}) {\n    const res = await api.post('ls', {\n      timeout: options.timeout,\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${Buffer.isBuffer(path) ? new CID(path) : path}`,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (let result of res.ndjson()) {\n      result = result.Objects\n\n      if (!result) {\n        throw new Error('expected .Objects in results')\n      }\n\n      result = result[0]\n      if (!result) {\n        throw new Error('expected one array in results.Objects')\n      }\n\n      result = result.Links\n      if (!Array.isArray(result)) {\n        throw new Error('expected one array in results.Objects[0].Links')\n      }\n\n      for (const link of result) {\n        const entry = {\n          name: link.Name,\n          path: path + '/' + link.Name,\n          size: link.Size,\n          cid: new CID(link.Hash),\n          type: typeOf(link),\n          depth: link.Depth || 1\n        }\n\n        if (link.Mode) {\n          entry.mode = parseInt(link.Mode, 8)\n        }\n\n        if (link.Mtime !== undefined && link.Mtime !== null) {\n          entry.mtime = {\n            secs: link.Mtime\n          }\n\n          if (link.MtimeNsecs !== undefined && link.MtimeNsecs !== null) {\n            entry.mtime.nsecs = link.MtimeNsecs\n          }\n        }\n\n        yield entry\n      }\n    }\n  }\n})\n\nfunction typeOf (link) {\n  switch (link.Type) {\n    case 1:\n    case 5:\n      return 'dir'\n    case 2:\n      return 'file'\n    default:\n      return 'unknown'\n  }\n}\n"]},"metadata":{},"sourceType":"script"}